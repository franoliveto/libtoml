#include "lex.h"

#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct lex_test {
  const char *name;
  const char *input;
  struct item items[20];
  int nitems;
} lex_tests[] = {
    {"empty", "", {{lex_eof, ""}}, 1},
    {"spaces", " \t", {{lex_eof, ""}}, 1},
    {"comments",
     "# this is a comment # just another comment",
     {{lex_eof, ""}},
     1},
    {"newlines",
     " \t\n\r\n",
     {{lex_NEWLINE, ""}, {lex_NEWLINE, ""}, {lex_eof, ""}},
     3},
    {"bare key", "abc-df_", {{lex_BARE_KEY, "abc-df_"}, {lex_eof, ""}}, 2},
    {"bare key start underscore",
     "_abcdf",
     {{lex_BARE_KEY, "_abcdf"}, {lex_eof, ""}},
     2},
    {"bare key start dash",
     "-abcdf",
     {{lex_BARE_KEY, "-abcdf"}, {lex_eof, ""}},
     2},
    {"float inf", "inf", {{lex_FLOAT, "inf"}, {lex_eof, ""}}, 2},
    {"float plus inf", "+inf", {{lex_FLOAT, "+inf"}, {lex_eof, ""}}, 2},
    {"float minus inf", "-inf", {{lex_FLOAT, "-inf"}, {lex_eof, ""}}, 2},
    {"float nan", "nan", {{lex_FLOAT, "nan"}, {lex_eof, ""}}, 2},
    {"float plus nan", "+nan", {{lex_FLOAT, "+nan"}, {lex_eof, ""}}, 2},
    {"float minus nan", "-nan", {{lex_FLOAT, "-nan"}, {lex_eof, ""}}, 2},
    {"positive integer", "+99", {{lex_INTEGER, "+99"}, {lex_eof, ""}}, 2},
    {"positive integer with newline",
     "+99\n",
     {{lex_INTEGER, "+99"}, {lex_NEWLINE, ""}, {lex_eof, ""}},
     3},
    {"negative integer", "-17", {{lex_INTEGER, "-17"}, {lex_eof, ""}}, 2},
    {"negative integer with newline",
     "-17\n",
     {{lex_INTEGER, "-17"}, {lex_NEWLINE, ""}, {lex_eof, ""}},
     3},
    {"zero positive integer", "+0", {{lex_INTEGER, "+0"}, {lex_eof, ""}}, 2},
    {"zero negative integer", "-0", {{lex_INTEGER, "-0"}, {lex_eof, ""}}, 2},
    {"zero integer", "0", {{lex_INTEGER, "0"}, {lex_eof, ""}}, 2},
    {"integer", "42", {{lex_INTEGER, "42"}, {lex_eof, ""}}, 2},
    {"one digit integer", "4", {{lex_INTEGER, "4"}, {lex_eof, ""}}, 2},
    {"indian system integer",
     "53_49_221",
     {{lex_INTEGER, "5349221"}, {lex_eof, ""}},
     2},
    {"indian system integer with newline",
     "53_49_221\n",
     {{lex_INTEGER, "5349221"}, {lex_NEWLINE, ""}, {lex_eof, ""}},
     3},
    {"negative indian system integer",
     "-53_49_221",
     {{lex_INTEGER, "-5349221"}, {lex_eof, ""}},
     2},
    {"negative indian system integer with newline",
     "-53_49_221\n",
     {{lex_INTEGER, "-5349221"}, {lex_NEWLINE, ""}, {lex_eof, ""}},
     3},
    {"indian system hexadecimal",
     "0xde_ad_be_ef",
     {{lex_INTEGER, "0xdeadbeef"}, {lex_eof, ""}},
     2},
    {"hexadecimal",
     "0xdeadbeef",
     {{lex_INTEGER, "0xdeadbeef"}, {lex_eof, ""}},
     2},
    {"octal", "0o755", {{lex_INTEGER, "0o755"}, {lex_eof, ""}}, 2},
    {"binary", "0b0101010", {{lex_INTEGER, "0b0101010"}, {lex_eof, ""}}, 2},
    {"positive float", "+1.0", {{lex_FLOAT, "+1.0"}, {lex_eof, ""}}, 2},
    {"fractional float", "3.1415", {{lex_FLOAT, "3.1415"}, {lex_eof, ""}}, 2},
    {"negative float", "-0.01", {{lex_FLOAT, "-0.01"}, {lex_eof, ""}}, 2},
    {"positive exponent float",
     "+5e+22",
     {{lex_FLOAT, "+5e+22"}, {lex_eof, ""}},
     2},
    {"exponent float", "1e06", {{lex_FLOAT, "1e06"}, {lex_eof, ""}}, 2},
    {"negative exponent float",
     "-2E-2",
     {{lex_FLOAT, "-2E-2"}, {lex_eof, ""}},
     2},
    {"scientific float",
     "6.626e-34",
     {{lex_FLOAT, "6.626e-34"}, {lex_eof, ""}},
     2},
    {"boolean true", "true", {{lex_BOOL, "true"}, {lex_eof, ""}}, 2},
    {"boolean false", "false", {{lex_BOOL, "false"}, {lex_eof, ""}}, 2},
    {"full date time",
     "1979-05-27T00:32:00.999999-07:00",
     {{lex_TIME, "1979-05-27T00:32:00.999999-07:00"}, {lex_eof, ""}},
     2},
    {"date time",
     "1979-05-27 00:32:00Z",
     {{lex_TIME, "1979-05-27 00:32:00Z"}, {lex_eof, ""}},
     2},
    {"basic string",
     "\"hello, world\"",
     {{lex_STRING, "hello, world"}, {lex_eof, ""}},
     2},
    {"basic string with escape",
     "\"hello\\r\\nworld\"",
     {{lex_STRING, "hello\r\nworld"}, {lex_eof, ""}},
     2},
    {"multi-line string",
     "\"\"\"hello, world\"\"\"",
     {{lex_STRING, "hello, world"}, {lex_eof, ""}},
     2},
    {"multi-line string with \"\" at end",
     "\"\"\"hello, world\"\"\"\"\"",
     {{lex_STRING, "hello, world\"\""}, {lex_eof, ""}},
     2},
    {"multi-line string with backlash",
     "\"\"\"hello, \\\n\nworld\"\"\"",
     {{lex_STRING, "hello, world"}, {lex_eof, ""}},
     2},
    {"multi-line string full",
     "\"\"\"\"This, \"she said, \"is just a pointless statement.\"\"\"\"",
     {{lex_STRING, "\"This, \"she said, \"is just a pointless statement.\""},
      {lex_eof, ""}},
     2},
    {"basic literal string",
     "\'C:\\Users\\paul\\sandbox\'",
     {{lex_STRING, "C:\\Users\\paul\\sandbox"}, {lex_eof, ""}},
     2},
    {"key and value",
     "greet = \"hello, world\"",
     {{lex_BARE_KEY, "greet"},
      {'=', "="},
      {lex_STRING, "hello, world"},
      {lex_eof, ""}},
     4},
    {"array of strings",
     "colors = [\"red\", \"yellow\", \"green\"]",
     {{lex_BARE_KEY, "colors"},
      {'=', "="},
      {'[', "["},
      {lex_STRING, "red"},
      {',', ","},
      {lex_STRING, "yellow"},
      {',', ","},
      {lex_STRING, "green"},
      {']', "]"},
      {lex_eof, ""}},
     10},
    {"inline table",
     "point = { x = 1, y = 2 }",
     {{lex_BARE_KEY, "point"},
      {'=', "="},
      {'{', "{"},
      {lex_BARE_KEY, "x"},
      {'=', "="},
      {lex_INTEGER, "1"},
      {',', ","},
      {lex_BARE_KEY, "y"},
      {'=', "="},
      {lex_INTEGER, "2"},
      {'}', "}"},
      {lex_eof, ""}},
     12},
    {"table",
     "[servers]\nip = \"192.168.0.3\"",
     {{'[', "["},
      {lex_BARE_KEY, "servers"},
      {']', "]"},
      {lex_NEWLINE, ""},
      {lex_BARE_KEY, "ip"},
      {'=', "="},
      {lex_STRING, "192.168.0.3"},
      {lex_eof, ""}},
     8},
    {"dotted table",
     "[dog.\"tater.man\"]",
     {{'[', "["},
      {lex_BARE_KEY, "dog"},
      {'.', "."},
      {lex_STRING, "tater.man"},
      {']', "]"},
      {lex_eof, ""}},
     6},
    {"dotted key",
     "physical.color = \"orange\"",
     {{lex_BARE_KEY, "physical"},
      {'.', "."},
      {lex_BARE_KEY, "color"},
      {'=', "="},
      {lex_STRING, "orange"},
      {lex_eof, ""}},
     6},
    {"array of tables",
     "[[products]]\nname = \"hammer\"\n[[products]]\r\n",
     {{lex_LEFT_BRACKETS, "[["},
      {lex_BARE_KEY, "products"},
      {lex_RIGHT_BRACKETS, "]]"},
      {lex_NEWLINE, ""},
      {lex_BARE_KEY, "name"},
      {'=', "="},
      {lex_STRING, "hammer"},
      {lex_NEWLINE, ""},
      {lex_LEFT_BRACKETS, "[["},
      {lex_BARE_KEY, "products"},
      {lex_RIGHT_BRACKETS, "]]"},
      {lex_NEWLINE, ""},
      {lex_eof, ""}},
     13},
    {"error in string",
     "\"hello, world",
     {{lex_ERROR, "saw eof before '\"'"}},
     1},

    {NULL}}; /* marks the end of the tests */

int main()
{
  struct lexer lex;
  struct lex_test *t;
  int errors = 0;

  for (t = lex_tests; t->input != NULL; t++) {
    lex_init(&lex, t->input);
    for (int i = 0; i < t->nitems; i++) {
      lex_scan_next(&lex);
      if (t->items[i].type != lex.item.type ||
          strcmp(t->items[i].val, lex.item.val) != 0) {
        fprintf(stderr, "%s: got \"%s\" (%d), expected \"%s\" (%d)\n", t->name,
                lex.item.val, lex.item.type, t->items[i].val, t->items[i].type);
        errors++;
      }
    }
  }
  if (errors > 0)
    fputs("FAIL\n", stderr);
  else
    fputs("PASS\n", stdout);
  return errors;
}
